// Generated by IcedCoffeeScript 1.7.1-b
describe('JSONP', function() {
  var Exceptions, jsonp;
  jsonp = null;
  Exceptions = null;
  before(function(done) {
    return requirejs(['jsonp', 'exceptions'], function(JSONP, E) {
      Exceptions = E;
      jsonp = new JSONP();
      return done();
    });
  });
  afterEach(function() {
    cookie.empty();
    trak.io._protocol = 'https';
    trak.io._host = 'api.trak.io';
    trak.io._current_context = false;
    trak.io._channel = false;
    trak.io._distinct_id = null;
    return trak.io._should_track = true;
  });
  describe('#call', function() {
    after(function() {
      jsonp.jsonp.restore();
      return jsonp.url.restore();
    });
    return it("calls jsonp passing endpoint and params through #url", function() {
      var jsonp_method;
      jsonp_method = sinon.stub(jsonp, "jsonp");
      sinon.stub(jsonp, "url").returns('the url to call');
      jsonp.call('endpoint');
      return jsonp_method.should.have.been.calledWith('the url to call');
    });
  });
  describe('#callback', function() {
    it("does nothing when request is a success", function() {
      var callback;
      callback = sinon.spy();
      expect(function() {
        return jsonp.callback({
          status: 'success'
        }, callback);
      }).to.not["throw"](Error);
      return callback.should.have.been.calledWith({
        status: 'success'
      });
    });
    it("raises a DataObjectInvalid exception", function() {
      return expect(function() {
        return jsonp.callback({
          status: "error",
          exception: "DataObjectInvalid"
        });
      }).to["throw"](Exceptions.DataObjectInvalid);
    });
    it("raises a DuplicatedDistinctIds exception", function() {
      return expect(function() {
        return jsonp.callback({
          status: "error",
          exception: "DuplicatedDistinctIds"
        });
      }).to["throw"](Exceptions.DuplicatedDistinctIds);
    });
    it("raises a InternalServiceError exception", function() {
      return expect(function() {
        return jsonp.callback({
          status: "error",
          exception: "InternalServiceError"
        });
      }).to["throw"](Exceptions.InternalServiceError);
    });
    it("raises a InvalidToken exception", function() {
      return expect(function() {
        return jsonp.callback({
          status: "error",
          exception: "InvalidToken"
        });
      }).to["throw"](Exceptions.InvalidToken);
    });
    it("raises a MissingParameter exception", function() {
      return expect(function() {
        return jsonp.callback({
          status: "error",
          exception: "MissingParameter"
        });
      }).to["throw"](Exceptions.MissingParameter);
    });
    it("raises a PersonNotFound exception", function() {
      return expect(function() {
        return jsonp.callback({
          status: "error",
          exception: "PersonNotFound"
        });
      }).to["throw"](Exceptions.PersonNotFound);
    });
    it("raises a PropertiesObjectInvalid exception", function() {
      return expect(function() {
        return jsonp.callback({
          status: "error",
          exception: "PropertiesObjectInvalid"
        });
      }).to["throw"](Exceptions.PropertiesObjectInvalid);
    });
    it("raises a RouteNotFound exception", function() {
      return expect(function() {
        return jsonp.callback({
          status: "error",
          exception: "RouteNotFound"
        });
      }).to["throw"](Exceptions.RouteNotFound);
    });
    it("raises a Timeout exception", function() {
      return expect(function() {
        return jsonp.callback({
          status: "error",
          exception: "Timeout"
        });
      }).to["throw"](Exceptions.Timeout);
    });
    it("raises an Unknown exception if exception is unknown", function() {
      return expect(function() {
        return jsonp.callback({
          status: "error",
          exception: "NotAKnownException"
        });
      }).to["throw"](Exceptions.Unknown);
    });
    it("sets the exception's code", function() {
      var error;
      try {
        return jsonp.callback({
          status: "error",
          code: 123
        });
      } catch (_error) {
        error = _error;
        return error.code.should.equal(123);
      }
    });
    it("sets the exception's message", function() {
      var error;
      try {
        return jsonp.callback({
          status: "error",
          message: "my message"
        });
      } catch (_error) {
        error = _error;
        return error.message.should.equal("my message");
      }
    });
    it("sets the exception's details", function() {
      var error;
      try {
        return jsonp.callback({
          status: "error",
          details: "my details"
        });
      } catch (_error) {
        error = _error;
        return error.details.should.equal("my details");
      }
    });
    return it("sets the exception's data", function() {
      var error;
      try {
        return jsonp.callback({
          status: "error",
          foo: "bar"
        });
      } catch (_error) {
        error = _error;
        return error.data.should.deep.equal({
          status: "error",
          foo: "bar"
        });
      }
    });
  });
  describe('#url', function() {
    afterEach(function() {
      trak.io.protocol.restore();
      trak.io.host.restore();
      trak.io.api_token.restore();
      return jsonp.default_params.restore();
    });
    return it("joins Trak#protocol Trak#host / endpoint and params for endpoint", function() {
      sinon.stub(trak.io, "protocol").returns('mcp://');
      sinon.stub(trak.io, "host").returns('my_host.com');
      sinon.stub(trak.io, "api_token").returns('api_token');
      sinon.stub(jsonp, "default_params").returns({
        override: 'foo',
        keep: 'foo'
      });
      return jsonp.url('my_endpoint', {
        override: 'bar'
      }).should.equal('mcp://my_host.com/my_endpoint?override=bar&keep=foo');
    });
  });
  describe('#params', function() {
    afterEach(function() {
      return jsonp.default_params.restore();
    });
    it("merges provided params with defaults for endpoint", function() {
      sinon.stub(jsonp, 'default_params').returns({
        override: 'foo',
        keep: 'foo'
      });
      return jsonp.params('endpoint', {
        override: 'bar'
      }).should.equal("?override=bar&keep=foo");
    });
    it("merges nested objects and encodes them to json", function() {
      sinon.stub(jsonp, 'default_params').returns({
        top: 'top',
        nested: {
          override: 'foo',
          keep: 'foo',
          second: {
            override: 'foo',
            keep: 'foo'
          }
        }
      });
      return jsonp.params('endpoint', {
        nested: {
          override: 'bar',
          second: {
            override: 'bar'
          }
        }
      }).should.equal('?top=top&nested=' + encodeURIComponent('{"override":"bar","keep":"foo","second":{"override":"bar","keep":"foo"}}'));
    });
    return it("merges arrays and encodes them to json", function() {
      sinon.stub(jsonp, 'default_params').returns({
        top: 'top',
        array: ['foo', 'duplicate']
      });
      return jsonp.params('endpoint', {
        array: ['duplicate', 'bar']
      }).should.equal('?top=top&array=' + encodeURIComponent('["foo","duplicate","bar"]'));
    });
  });
  describe('#default_params', function() {
    beforeEach(function() {
      sinon.stub(trak.io, "distinct_id").returns('distinct_id_value');
      sinon.stub(trak.io, "company_id").returns('company_id_value');
      sinon.stub(trak.io, "api_token").returns('api_token_value');
      sinon.stub(trak.io, "channel").returns('channel_value');
      return sinon.stub(trak.io, "context").returns('context_value');
    });
    afterEach(function() {
      trak.io.distinct_id.restore();
      trak.io.company_id.restore();
      trak.io.api_token.restore();
      trak.io.channel.restore();
      return trak.io.context.restore();
    });
    it("returns default params for alias", function() {
      return jsonp.default_params('alias').should.eql({
        token: 'api_token_value',
        data: {
          distinct_id: 'distinct_id_value'
        }
      });
    });
    it("returns default params for identify", function() {
      return jsonp.default_params('identify').should.eql({
        token: 'api_token_value',
        data: {
          distinct_id: 'distinct_id_value',
          properties: {}
        }
      });
    });
    it("returns default params for track", function() {
      return jsonp.default_params('track').should.eql({
        token: 'api_token_value',
        data: {
          distinct_id: 'distinct_id_value',
          properties: {},
          channel: 'channel_value',
          context: 'context_value'
        }
      });
    });
    it("returns default params for company", function() {
      return jsonp.default_params('company').should.eql({
        token: 'api_token_value',
        data: {
          company_id: 'company_id_value',
          properties: {}
        }
      });
    });
    return it("returns empty object for unknown", function() {
      return jsonp.default_params('jibersih').should.eql({});
    });
  });
  describe('#noop', function() {
    return it("does nothing, zip, nadda", function() {
      return expect(jsonp.noop()).to.equal(void 0);
    });
  });
  return describe('#jsonp', function() {
    it("creates and inserts a script tag for the provided url", function() {
      jsonp.jsonp('/test/empty.json');
      return $("script[src^='/test/empty.json']").should.exist;
    });
    it("adds its own callback param", function() {
      jsonp.jsonp('/test/empty.json');
      return $("script[src$='callback=__trak" + (jsonp.count - 1) + "']").should.exist;
    });
    it("when __trak* called cleans up and calls callback", function() {
      var callback;
      callback = sinon.stub(jsonp, 'callback');
      jsonp.jsonp('/test/empty.json');
      window["__trak" + (jsonp.count - 1)]({
        some: 'data'
      });
      callback.should.have.been.calledWith({
        some: 'data'
      });
      $("script[src$='callback=__trak" + (jsonp.count - 1) + "']").should.not.exist;
      return callback.restore();
    });
    return it("triggers #callback with timeout error if script hasn't executed by timeout", function() {
      var callback, clock;
      clock = sinon.useFakeTimers();
      callback = sinon.stub(jsonp, 'callback');
      jsonp.jsonp('/test/empty.json');
      clock.tick(10001);
      callback.should.have.been.calledWith({
        status: 'error',
        exception: 'TrakioAPI::Exceptions::Timeout',
        message: "The server failed to respond in time."
      });
      $("script[src$='callback=__trak" + (jsonp.count - 1) + "']").should.not.exist;
      clock.restore();
      return callback.restore();
    });
  });
});
